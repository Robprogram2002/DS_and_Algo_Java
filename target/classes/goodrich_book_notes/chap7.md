## The List ADT

In this chapter, we explore several abstract data types that represent a linear sequence of elements, but with more
general support for adding or removing elements at arbitrary positions. However, designing a single abstraction that is
well suited for efficient implementation with either an array or a linked list is challenging, given the very different
nature of these two fundamental data structures.

With that said, Java defines a general interface, java.util.List, that includes the following index-based methods (and
more):

- size( ): Returns the number of elements in the list.
- isEmpty( ): Returns a boolean indicating whether the list is empty.
- get(i): Returns the element of the list having index i; an error condition occurs if `i` is not in
  range `[0,size( )−1]`.
- set(i, e): Replaces the element at index i with e, and returns the old element that was replaced; an error condition
  occurs if `i` is not in range `[0,size( )−1]`.
- add(i, e): Inserts a new element e into the list so that it has index i, moving all subsequent elements one index
  later in the list; an error condition occurs if `i` is not in range `[0,size( )]`.
- remove(i): Removes and returns the element at index i, moving all subsequent elements one index earlier in the list;
  an error condition occurs if `i` is not in range `[0,size( )−1]`.

We note that the index of an existing element may change over time, as other elements are added or removed in front of
it. We also draw attention to the fact that the range of valid indices for the add method includes the current size of
the list, in which case the new element becomes the last.

### 7.2 Array Lists

The first key to providing the semantics of an unbounded array is that an array list instance maintains an internal
array that often has greater capacity than the current length of the list. For example, while a user may have created a
list with five elements, the system may have reserved an underlying array capable of storing eight object references (
rather than only five). This extra capacity makes it easy to add a new element to the end of the list by using the next
available cell of the array.

If a user continues to add elements to a list, all reserved capacity in the underlying array will eventually be
exhausted. In that case, the class requests a new, larger array from the system, and copies all references from the
smaller array into the beginning of the new array. At that point in time, the old array is no longer needed, so it can
be reclaimed by the system.

###### Java’s StringBuilder class

Previously We observed that the StringBuilder was significantly faster than concatenation, with empirical evidence that
suggested a quadratic running time for the algorithm with repeated concatenations, and a linear running time for the
algorithm with the StringBuilder. We are now able to explain the theoretical underpinning for those observations.

The StringBuilder class represents a mutable string by storing characters in a dynamic array.This guarantees that a
series of append operations resulting in a string of length n execute in a combined time of O(n). (Insertions at
positions other than the end of a string builder do not carry this guarantee, just as they do not for an ArrayList.)

In contrast, the repeated use of string concatenation requires quadratic time. In effect, that approach is akin to a
dynamic array with an arithmetic progression of size one, repeatedly copying all characters from one array to a new
array with size one greater than before.

### Positional Lists

## Iterators

An **iterator** is a software design pattern that abstracts the process of scanning through a sequence of elements, one
element at a time. The underlying elements might be stored in a container class, streaming through a network, or
generated by a series of computations.

In order to unify the treatment and syntax for iterating objects in a way that is independent from a specific
organization, Java defines the `java.util.Iterator` interface with the following two methods:

- **hasNext( )**: Returns true if there is at least one additional element in the sequence, and false otherwise.
- **next( )**: Returns the next element in the sequence.

The interface uses Java’s generic framework, with the next( ) method returning a parameterized element type

If the next( ) method of an iterator is called when no further elements are available, a **NoSuchElementException** is
thrown. Of course, the hasNext( ) method can be used to detect that condition before calling next( ). The combination of
these two methods allows a general loop construct for processing elements of the iterator. For example, if we let
variable, iter, denote an instance of the Iterator<String> type, then we can write the following:

    while (iter.hasNext( )) {
      String value = iter.next( );
      System.out.println(value);
    }

The `java.util.Iterator` interface contains a third method, which is optionally supported by some iterators:

- **remove( )**: Removes from the collection the element returned by the most recent call to next( ). Throws an
  IllegalStateException if next has not yet been called, or if remove was already called since the most recent call to
  next

This method can be used to filter a collection of elements, for example to discard all negative numbers from a data set.
If removal is not supported, an **UnsupportedOperationException** is conventionally thrown.

#### The Iterable Interface and Java’s For-Each Loop

A single iterator instance supports only one pass through a collection; calls to next can be made until all elements
have been reported, but there is no way to “reset” the iterator back to the beginning of the sequence.

However, a data structure that wishes to allow repeated iterations can support a method that returns a *new* iterator,
each time it is called. To provide greater standardization, Java defines another parameterized interface, named
Iterable, that includes the following single method:

- **iterator( )**: Returns an iterator of the elements in the collection.

An instance of a typical collection class in Java, such as an ArrayList, is iterable (but not itself an **iterator**);
it produces an iterator for its collection as the return value of the iterator( ) method. Each call to iterator( )
returns a new iterator instance, thereby allowing multiple (even simultaneous) traversals of a collection.

Java’s Iterable class also plays a fundamental role in support of the “for-each” loop syntax. The loop syntax,

    for (ElementType variable : collection) {
      loopBody                                      // may refer to ”variable”
    }

is supported for any instance, *collection*, of an iterable class. *ElementType* must be the type of object returned by
its iterator.

    Iterator<ElementType> iter = collection.iterator( );
    while (iter.hasNext( )) {
      ElementType variable = iter.next( );
      loopBody // may refer to ”variable”
    }

We note that the iterator’s remove method cannot be invoked when using the for-each loop syntax. Instead, we must
explicitly use an iterator. As an example, the following loop can be used to remove all negative numbers from an
ArrayList of floating-point values.

    ArrayList<Double> data;                               // populate with random numbers (not shown)
    Iterator<Double> walk = data.iterator( );
    while (walk.hasNext( ))
      if (walk.next( ) < 0.0)
        walk.remove( )

#### Implementing Iterator

There are two general styles for implementing iterators that differ in terms of what work is done when the iterator
instance is first created, and what work is done each time the iterator is advanced with a call to next( ).

A **snapshot iterator** maintains its own private copy of the sequence of elements, which is constructed at the time the
iterator object is created. It effectively records a “snapshot” of the sequence of elements at the time the iterator is
created, and is therefore unaffected by any subsequent changes to the primary collection that may occur. Implementing
snapshot iterators tends to be very easy, as it requires a simple traversal of the primary structure. The downside of
this style of iterator is that it requires O(n) time and O(n) auxiliary space, upon construction, to copy and store a
collection of n elements.

A **lazy iterator** is one that does not make an upfront copy, instead performing a piecewise traversal of the primary
structure only when the next( ) method is called to request another element. The advantage of this style of iterator is
that it can typically be implemented so the iterator requires only O(1) space and O(1)
construction time. One downside (or feature) of a lazy iterator is that its behavior is affected if the primary
structure is modified (by means other than by the iterator’s own remove method) before the iteration completes. Many of
the iterators in Java’s libraries implement a “fail-fast” behavior that immediately invalidates such an iterator if its
underlying collection is modified unexpectedly.

We will demonstrate how to implement iterators for both the ArrayList and LinkedPositionalList classes as examples. We
implement lazy iterators for both, including support for the remove operation (but without any fail-fast guarantee).

we must add an iterator( ) method to that class definition, which returns an instance of an object that implements the
`Iterator<E>` interface.

## The Java Collections Framework

Java provides many data structure interfaces and classes, which together form the **Java Collections Framework**. This
framework, which is part of the java.util package, includes versions of several of the data structures discussed in this
book.

The root interface in the Java Collections framework is named **Collection**. This is a general interface for any data
structure, such as a list, that represents a collection of elements. The Collection interface includes many methods,
including some we have already seen (e.g., `size( ), isEmpty( ), iterator( )`). It is a *superinterface* for other
interfaces in the Java Collections Framework that can hold elements.

The Java Collections Framework also includes concrete classes implementing various interfaces with a combination of
properties and underlying representations.

Some classes enforce, or allow, a fixed capacity limit. Robust classes provide support for **concurrency**, allowing
multiple processes to share use of a data structure in a thread-safe manner. If the structure is designated as blocking,
a call to retrieve an element from an empty collection waits until some other process inserts an element. Similarly, a
call to insert into a full blocking structure must wait until room becomes available.

##### List Iterators in Jav

##### Comparison to Our Positional List ADT

##### List-Based Algorithms in the Java Collections Framework

In addition to the classes that are provided in the Java Collections Framework, there are a number of simple algorithms
that it provides as well. These algorithms are implemented as static methods in the java.util.Collections class (not to
be confused with the java.util.Collection interface) and they include the following methods:

- **copy(L_dest , L_src)**: Copies all elements of the L_src list into corresponding indices of the Ldest list.
- **disjoint(C, D)**: Returns a boolean value indicating whether the collections C and D are disjoint
- **fill(L, e)**: Replaces each element of the list L with element e.
- **frequency(C, e)**: Returns the number of elements in the collection C that are equal to e.
- **max(C)**: Returns the maximum element in the collection C, based on the natural ordering of its elements.
- **min(C)**: Returns the minimum element in the collection C, based on the natural ordering of its elements.
- **replaceAll(L, e, f)**: Replaces each element in L that is equal to e with element f .
- **reverse(L)**: Reverses the ordering of elements in the list L.
- **rotate(L, d)**: Rotates the elements in the list L by the distance d (which can be negative), in a circular fashion
- **shuffle(L)**: Pseudorandomly permutes the ordering of the elements in the list L.
- **sort(L)**: Sorts the list L, using the natural ordering of its elements.
- **swap(L, i, j)**: Swap the elements at indices i and j of list L.

**Converting Lists into Arrays.**
There are some instances where it would be useful if we could treat a list like an array. Fortunately, the
java.util.Collection interface includes the following helpful methods for generating an array that has the same elements
as the given collection:

- **toArray( )**: Returns an array of elements of type Object containing all the elements in this collection.
- **toArray(A)**: Returns an array of elements of the same element type as A containing all the elements in this
  collection.

If the collection is a list, then the returned array will have its elements stored in the same order as that of the
original list. Thus, if we have a useful array-based method that we want to use on a list or other type of collection,
then we can do so by simply using that collection’s toArray( ) method to produce an array representation of that
collection.

**Converting Arrays into Lists.**

In a similar vein, it is often useful to be able to convert an array into an equivalent list. Fortunately, the
java.util.Arrays class includes the following method:

- **asList(A)**: Returns a list representation of the array A, with the same element type as the elements of A.

The list returned by this method uses the array A as its internal representation for the list. So this list is
guaranteed to be an array-based list and any changes made to it will automatically be reflected in A. Because of these
types of side effects, use of the asList method should always be done with caution, so to avoid unintended consequences.
But, used with care, this method can often save us a lot of work.

For instance, the following code fragment could be used to randomly shuffle an array of Integer objects, arr:

    Integer[ ] arr = {1, 2, 3, 4, 5, 6, 7, 8}; // allowed by autoboxing
    List<Integer> listArr = Arrays.asList(arr);
    Collections.shuffle(listArr); // this has side effect of shuffling arr

It is worth noting that the array A sent to the asList method should be a reference type (hence, our use of Integer
rather than int in the above example). This is because the List interface is generic, and requires that the element type
be an object.